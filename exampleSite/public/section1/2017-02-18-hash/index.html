<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=http://localhost:1313/favicon//favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=http://localhost:1313/favicon//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=http://localhost:1313/favicon//apple-touch-icon.png><meta name=description content><title>java散列知识点总结 | My website
</title><link rel=canonical href=http://localhost:1313/section1/2017-02-18-hash/><meta property="og:url" content="http://localhost:1313/section1/2017-02-18-hash/"><meta property="og:site_name" content="My website"><meta property="og:title" content="java散列知识点总结"><meta property="og:description" content="java 的根类 Object 具有 hashcode 方法。当 equal 方法被重写时也应当重写 hashcode 方法。
基本数据类型的散列码 # byte short int char 类型的搜索键将会转换为 int。 float 类型的搜索键使用 Float.floatToIntBits(key) 作为散列码。 long 类型的搜索键会进行折叠操作，如下： iny hashCode = (int) (key ^ (key >> 32)); double 类型的搜索键会使用 Double.doubleToLongBits(key) 方法转换为 long 类型然后再进行折叠。 字符串类型的散列码 # 对于字符串一般使用多项式散列码进行计算，
这里放个公式的图
b的较好取值为31，33，37，39，41。在 java String 类中 b 取31。
public static int hash(String key, int tableSize) { int hashVal = 0; for (int i = 0; i < key.length(); i++) hashVal = 37*hashVal + key.charAt(i); hashVal %= tableSize; if (hashVal < 0) hashVal += tableSize; return hashVal; } 压缩散列码 # 由于散列码可能是很大的正数，通常应该对其进行压缩以防止超出索引的范围。若索引范围为 0 ~ n - 1 ，通常的做法是 h(hashCode) = hashCode % N ，选择N为大于2的素数。 java.util.HashMap 的实现中，将N设置为2的幂值，这样可以使用位运算代替上述的取模：h(hashCode) = hashCode & (N - 1) ，两者是完全等价的。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="section1"><meta property="article:published_time" content="2017-02-18T19:19:01+00:00"><meta property="article:modified_time" content="2017-02-18T19:19:01+00:00"><meta property="article:tag" content="Algorithms"><link rel=stylesheet href=/assets/combined.min.bc288d1814b3b7b9b5c81393c3906556ff45f3896747ea7da530af6f34c88572.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=http://localhost:1313/ style=display:flex;align-items:center><img src=/favicon/apple-touch-icon.png alt=Icon height=40>
<span>Home Title</span></a></h1><div class=flex><p class=small><a href=http://localhost:1313/>/home</a></p><p class=small><a href=http://localhost:1313/section1/>/Section1</a></p><p class=small><a href=http://localhost:1313/section2/>/Section2</a></p><p class=small><a href=http://localhost:1313/about>/about</a></p></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/section1/>Section 1</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/section1/2017-02-18-hash/>java散列知识点总结</a></div><div><div class=single-intro-container><h1 class=single-title>java散列知识点总结</h1><p class=single-readtime><time datetime=2017-02-18T19:19:01+00:00>Feb 18, 2017</time></p></div><div class=single-content><p>java 的根类 <code>Object</code> 具有 <code>hashcode</code> 方法。当 <code>equal</code> 方法被重写时也应当重写 <code>hashcode</code> 方法。</p><h2 class=heading id=基本数据类型的散列码>基本数据类型的散列码
<a href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%95%a3%e5%88%97%e7%a0%81>#</a></h2><ul><li><code>byte</code> <code>short</code> <code>int</code> <code>char</code> 类型的搜索键将会转换为 <code>int</code>。</li><li><code>float</code> 类型的搜索键使用 <code>Float.floatToIntBits(key)</code> 作为散列码。</li><li><code>long</code> 类型的搜索键会进行折叠操作，如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>iny hashCode <span style=color:#ff6ac1>=</span> (<span style=color:#9aedfe>int</span>) (key <span style=color:#ff6ac1>^</span> (key <span style=color:#ff6ac1>&gt;&gt;</span> 32));
</span></span></code></pre></div><ul><li><code>double</code> 类型的搜索键会使用 <code>Double.doubleToLongBits(key)</code> 方法转换为 <code>long</code> 类型然后再进行折叠。</li></ul><h2 class=heading id=字符串类型的散列码>字符串类型的散列码
<a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%95%a3%e5%88%97%e7%a0%81>#</a></h2><p>对于字符串一般使用多项式散列码进行计算，</p><p><del>这里放个公式的图</del></p><p>b的较好取值为31，33，37，39，41。在 java String 类中 <code>b</code> 取31。</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>static</span> <span style=color:#9aedfe>int</span> <span style=color:#57c7ff>hash</span>(String key, <span style=color:#9aedfe>int</span> tableSize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#9aedfe>int</span> hashVal <span style=color:#ff6ac1>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> i <span style=color:#ff6ac1>=</span> 0; i <span style=color:#ff6ac1>&lt;</span> key.<span style=color:#57c7ff>length</span>(); i<span style=color:#ff6ac1>++</span>)
</span></span><span style=display:flex><span>        hashVal <span style=color:#ff6ac1>=</span> 37<span style=color:#ff6ac1>*</span>hashVal <span style=color:#ff6ac1>+</span> key.<span style=color:#57c7ff>charAt</span>(i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hashVal <span style=color:#ff6ac1>%=</span> tableSize;
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (hashVal <span style=color:#ff6ac1>&lt;</span> 0)
</span></span><span style=display:flex><span>        hashVal <span style=color:#ff6ac1>+=</span> tableSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> hashVal;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 class=heading id=压缩散列码>压缩散列码
<a href=#%e5%8e%8b%e7%bc%a9%e6%95%a3%e5%88%97%e7%a0%81>#</a></h2><p>由于散列码可能是很大的正数，通常应该对其进行压缩以防止超出索引的范围。若索引范围为 <code>0 ~ n - 1</code> ，通常的做法是 <code>h(hashCode) = hashCode % N</code> ，选择N为大于2的素数。
<code>java.util.HashMap</code> 的实现中，将N设置为2的幂值，这样可以使用位运算代替上述的取模：<code>h(hashCode) = hashCode & (N - 1)</code> ，两者是完全等价的。</p><h2 class=heading id=处理冲突>处理冲突
<a href=#%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81>#</a></h2><h3 class=heading id=开放地址法>开放地址法
<a href=#%e5%bc%80%e6%94%be%e5%9c%b0%e5%9d%80%e6%b3%95>#</a></h3><p>开放地址法是在冲突发生时，在散列表中找到一个开放位置的过程。</p><ul><li>线性探测，存在成簇问题</li><li>二次探测，存在二次成簇问题，并且不能保证一个开放的单元总是可以被找到。</li><li>再哈希法</li></ul><h3 class=heading id=链地址法>链地址法
<a href=#%e9%93%be%e5%9c%b0%e5%9d%80%e6%b3%95>#</a></h3><p>链地址法是将具有同样索引的条目放在同一位置，每个位置使用一个桶(ArrayList or LinkedList)来放置多个条目。</p><h2 class=heading id=装填因子>装填因子
<a href=#%e8%a3%85%e5%a1%ab%e5%9b%a0%e5%ad%90>#</a></h2><p>装填因子衡量一个散列表有多满。<code>lamda = n / N</code> 。对于开放地址法，装填因子介于 0 ~ 1，对于链地址法，装填因子可能为任意值。通常开放地址法需要将装填因子维持在0.5以下，而链地址法为0.9以下。<code>java.util.HashMap</code> 采用了阈值0.75。</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/section1/2017-01-11-php-lambada/>php的闭包特性</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/section1/2019-01-18-es6/>ES6について</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>↑ Back to top</a></div></div></main></div><footer><div class=footer><p>© 2024 <a href=https://github.com/loyistro/Beige>loyistro/beige</a> theme</p></div></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>