<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=http://localhost:1313/favicon//favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=http://localhost:1313/favicon//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=http://localhost:1313/favicon//apple-touch-icon.png><meta name=description content><title>Algorithms - Graphs | My website
</title><link rel=canonical href=http://localhost:1313/section2/2020-05-01-algorithms-graphs/><meta property="og:url" content="http://localhost:1313/section2/2020-05-01-algorithms-graphs/"><meta property="og:site_name" content="My website"><meta property="og:title" content="Algorithms - Graphs"><meta property="og:description" content="Undirected Graphs # Some problems # Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once classical NP-complete problem. Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical? No one knows so far. A lonstanding open problem Representations # Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="section2"><meta property="article:published_time" content="2020-05-01T09:00:00+00:00"><meta property="article:modified_time" content="2020-05-01T09:00:00+00:00"><meta property="article:tag" content="Algorithms"><link rel=stylesheet href=/assets/combined.min.66a797937941435e268ae54e9b88cf13c013a2483a136952179be363089d0640.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=http://localhost:1313/ style=display:flex;align-items:center><img src=/favicon/apple-touch-icon.png alt=Icon height=40>
<span>Home Title</span></a></h1><div class="menu flex"><p class=menu-item><a href=http://localhost:1313/>/home</a></p><p class=menu-item><a href=http://localhost:1313/section1/>/Section1</a></p><p class=menu-item><a href=http://localhost:1313/section2/>/Section2</a></p><p class=menu-item><a href=http://localhost:1313/about>/about</a></p></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/section2/>Section 2</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/section2/2020-05-01-algorithms-graphs/>Algorithms - Graphs</a></div><div class=autonumber><div class=single-intro-container><h1 class=single-title>Algorithms - Graphs</h1><p class=single-readtime><time datetime=2020-05-01T09:00:00+00:00>May 1, 2020</time>
&nbsp; Â· &nbsp;
12 min read</p></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#undirected-graphs>Undirected Graphs</a><ul><li><a href=#some-problems>Some problems</a></li><li><a href=#representations>Representations</a></li><li><a href=#adjacency-list-data-structure>Adjacency-list Data structure</a></li><li><a href=#depth-first-search-dfs>Depth-first Search (DFS)</a></li><li><a href=#breadth-first-search-bfs>Breadth-first Search (BFS)</a></li><li><a href=#applications-of-dfs>Applications of DFS</a></li></ul></li><li><a href=#directed-graphs>Directed Graphs</a><ul><li><a href=#representations-1>Representations</a></li><li><a href=#digraph-search>Digraph search</a></li><li><a href=#topological-sort>Topological Sort</a></li><li><a href=#strong-components>Strong components</a></li></ul></li><li><a href=#minimum-spanning-trees>Minimum Spanning Trees</a><ul><li><a href=#edge-weight-graph-data-type>Edge-weight Graph Data Type</a></li><li><a href=#greedy-mst-algorithm><strong>Greedy MST Algorithm:</strong></a></li><li><a href=#implementations-1-kruskals-algorithm>Implementations 1: Kruskal&rsquo;s algorithm</a></li><li><a href=#implementations-2-prims-algorithm>Implementations 2: Prim&rsquo;s algorithm</a></li></ul></li><li><a href=#shortest-paths>Shortest Paths</a><ul><li><a href=#edge-weighted-digraph-data-strcuture>Edge-weighted digraph data strcuture</a></li><li><a href=#generic-single-source-shortest-paths>Generic Single-source Shortest paths</a></li><li><a href=#implement-1-dijkstras-algorithm>Implement 1: Dijkstra&rsquo;s algorithm</a></li><li><a href=#implement-2-topological-sort-algorithm>Implement 2: Topological sort algorithm</a></li><li><a href=#implement-3-bellman-ford-algorithm>Implement 3: Bellman-Ford algorithm</a></li></ul></li></ul></nav></aside><div class=single-content><h2 class=heading id=undirected-graphs>Undirected Graphs
<a href=#undirected-graphs>#</a></h2><h3 class=heading id=some-problems>Some problems
<a href=#some-problems>#</a></h3><ul><li>Path</li><li>Shortest path</li><li>Cycle</li><li>Ehler tour: A cycle that uses each edge excatly once.</li><li>Hamilton tour: A cycle that uses each vertex exactly once<ul><li>classical NP-complete problem.</li></ul></li><li>Connectivity</li><li>MST:</li><li>Biconnectivity: A vertex whose removal disconnects the graph</li><li>Planarity</li><li>Graph isomorphism: Are two graphs identical?<ul><li>No one knows so far. A lonstanding open problem</li></ul></li></ul><h3 class=heading id=representations>Representations
<a href=#representations>#</a></h3><p>Real-world graphs tend to be <strong>sparse</strong> (huge number of vertices, small average vertex degree).</p><ul><li>Set-of-edges representation<ul><li>unefficient</li></ul></li><li>Adjacency-matrix representation<ul><li>space cost is prohibitive</li></ul></li><li>Adjacency-list array representation<ul><li>GOOD</li></ul></li></ul><h3 class=heading id=adjacency-list-data-structure>Adjacency-list Data structure
<a href=#adjacency-list-data-structure>#</a></h3><ul><li>Space usage proportional to V + E</li><li>Constant time to add an edge</li><li>Time proportional to the degree of v to iterate through vertices adjacent to v</li></ul><h3 class=heading id=depth-first-search-dfs>Depth-first Search (DFS)
<a href=#depth-first-search-dfs>#</a></h3><p>Typical applications:</p><ul><li>Find all vertices connected to a given source vertex</li><li>Find a path between two vertices</li></ul><p>Algorithm:</p><ul><li>Use recursion (a function-call stack) or an explicit stack.</li><li>Mark each visited vertex (and keep track of edge taken to visit it)</li><li>Return (retrace steps) when no unvisited options</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>DepthFirstPaths</span>{
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> blloean<span style=color:#ff6ac1>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[]</span> edgeTO;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span> s;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>DepthFirstPaths</span>(Graph G, <span style=color:#9aedfe>int</span> s)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>        dfs(G, s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>dfs</span>(Graph Gm <span style=color:#9aedfe>int</span> v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> w : G.<span style=color:#57c7ff>adj</span>(v))
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(G, w)
</span></span><span style=display:flex><span>                edgeTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> v;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Propositions:</p><ol><li>DFS marks all vertices connected to s in time proportional to the sum of their degrees.</li><li>After DFS, can find vertices connected to s in constant time and can find a path to s in time proportional to its length.</li></ol><h3 class=heading id=breadth-first-search-bfs>Breadth-first Search (BFS)
<a href=#breadth-first-search-bfs>#</a></h3><p>Typical applications:</p><ul><li>shortest path</li></ul><p>Algorithm:</p><ul><li>Put s onto a queue, and mark s as visited</li><li>Take the next vertex v from the queue and mark it</li><li>Put onto the queue all unmarked vertices that are adjacent to v</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>BreadthFirstPaths</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>bfs</span>(Graph G, <span style=color:#9aedfe>int</span> s)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Queue<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;</span> q <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> Queue<span style=color:#ff6ac1>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        q.<span style=color:#57c7ff>enqueue</span>(s);
</span></span><span style=display:flex><span>        marked<span style=color:#ff6ac1>[</span>s<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> ture;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>while</span> (<span style=color:#ff6ac1>!</span>q.<span style=color:#57c7ff>isEmpty</span>())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> q.<span style=color:#57c7ff>dequeue</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> w: G.<span style=color:#57c7ff>adj</span>(v))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    q.<span style=color:#57c7ff>enqueue</span>(w);
</span></span><span style=display:flex><span>                    marked<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>                    edgeTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> v;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Proposition:</p><ol><li>BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V</li></ol><h3 class=heading id=applications-of-dfs>Applications of DFS
<a href=#applications-of-dfs>#</a></h3><h4 class=heading id=connected-components>Connected components
<a href=#connected-components>#</a></h4><p>The goal is to preprocess graph to answer queries of the form <em>is v connected to w?</em> in constant time.</p><p>The relation <em>is connected to</em> is an equivalence relation:</p><ul><li>Reflexive: v is connected to v</li><li>Symmetric: if v is connected to w, then w is connected to v</li><li>Transitive: if v connected to w and w connected to x, then v connected to x</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>CC</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[]</span> id;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>CC</span>(Graph G) {
</span></span><span style=display:flex><span>        marked <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        id <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> 0, v <span style=color:#ff6ac1>&lt;</span> G.<span style=color:#57c7ff>V</span>(); v<span style=color:#ff6ac1>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>) {
</span></span><span style=display:flex><span>                dfs(G, v);
</span></span><span style=display:flex><span>                count<span style=color:#ff6ac1>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>dfs</span>(Graph G, <span style=color:#9aedfe>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>        id<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> count;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> w : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>) {
</span></span><span style=display:flex><span>                dfs(G, w)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 class=heading id=cycle-detection>Cycle detection
<a href=#cycle-detection>#</a></h4><p>Problem: Is a given graph acylic?</p><p><strong>TODO</strong></p><h4 class=heading id=two-colorability>Two-colorability
<a href=#two-colorability>#</a></h4><p>Problem: Is the graph bipartite?</p><p><strong>TODO</strong></p><h4 class=heading id=symbol-graphs>Symbol graphs
<a href=#symbol-graphs>#</a></h4><p><strong>TODO</strong></p><h4 class=heading id=degrees-of-separation>Degrees of separation
<a href=#degrees-of-separation>#</a></h4><p><strong>TODO</strong></p><h2 class=heading id=directed-graphs>Directed Graphs
<a href=#directed-graphs>#</a></h2><blockquote><p>A directed graph (or digraph) is a set of vertices and a collection of directed edges. Each directed edge connects an ordered pair of vertices.</p></blockquote><ul><li><em>outdegree</em>: the number of edges going <strong>from</strong> it</li><li><em>indegree</em>: the number fo edges going <strong>into</strong> it</li><li><em>directed path</em>: a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence</li><li><em>directed cycle</em></li><li><em>simple cycle</em>: a cycle with no repeated edges or vertices</li></ul><h3 class=heading id=representations-1>Representations
<a href=#representations-1>#</a></h3><p>Again, use <a href=#Adjacency-list-Data-structure>adjacency-lists representation</a></p><ul><li>Based on iterating over vertices pointing from v</li><li>Real-world digraphs tend to be sparse</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>Digraph</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#ff5c57>final</span> <span style=color:#9aedfe>int</span> V;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#ff5c57>final</span> Bag<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;[]</span> adj;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>Digraph</span>(<span style=color:#9aedfe>int</span> V) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>this</span>.<span style=color:#57c7ff>V</span> <span style=color:#ff6ac1>=</span> V;
</span></span><span style=display:flex><span>        adj <span style=color:#ff6ac1>=</span> (Bag<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;[]</span>) <span style=color:#ff6ac1>new</span> Bag<span style=color:#ff6ac1>[</span>V<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> 0; v <span style=color:#ff6ac1>&lt;</span> V; v<span style=color:#ff6ac1>++</span>) {
</span></span><span style=display:flex><span>            adj<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> Bag<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;[]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>addEdge</span>(<span style=color:#9aedfe>int</span> v, <span style=color:#9aedfe>int</span> w) {
</span></span><span style=display:flex><span>        adj<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>.<span style=color:#57c7ff>add</span>(w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> Iterable<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;</span> <span style=color:#57c7ff>adj</span>(<span style=color:#9aedfe>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> adj<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 class=heading id=digraph-search>Digraph search
<a href=#digraph-search>#</a></h3><p>Reachabiliity problem: Find all vertices reachable from s along a directed path.</p><p>We can use <a href=#Depth-first-Search-(DFS)>the same dfs method as for undirected graphs</a>.</p><ul><li>Every undirected graph is a digraph with edges in both directions.</li><li>DFS is a digraph algorithm,</li></ul><p>Reachability applications:</p><ul><li>program control-flow analysis<ul><li>Dead-code elimination</li><li>infinite-loop detection</li></ul></li><li>mark-sweep garbage collector</li></ul><p>Other DFS problems:</p><ul><li>Path findind</li><li>Topological sort</li><li>Directed cycle detection</li><li>&mldr;</li></ul><p>BFS problems:</p><ul><li>shortest path</li><li>multiple-source shortest paths</li><li>web crawler application</li></ul><h3 class=heading id=topological-sort>Topological Sort
<a href=#topological-sort>#</a></h3><blockquote><p>Topological sort: Given a digraph, put the vertices in order such that all its directed edges point from a vertix earlier in the order to a vertex later in the order (or report impossible).</p></blockquote><p>A digraph has a topological order <strong>if and only if</strong> it is a <em>directed acyclic graph</em> (DAG).
Topological sort redraws DAG so all edges poitn upwards.</p><p>use <strong>DFS</strong> again. It can be proved that reverse postorder of a DAG is a topological order.
(check P578 for the definition of Preorder/Postorder)</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>DepthFirstOrder</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> Stack<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;</span> reversePost;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    publiv <span style=color:#57c7ff>DepthFirstOrder</span>(Digraph G) {
</span></span><span style=display:flex><span>        reversePost <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> Stack<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;</span>();
</span></span><span style=display:flex><span>        marked <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> 0; v <span style=color:#ff6ac1>&lt;</span> G.<span style=color:#57c7ff>V</span>(); v<span style=color:#ff6ac1>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>) dfs(G, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>dfs</span>(Digrapg G, <span style=color:#9aedfe>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> w : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>) dfs(G, w)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        reversePost.<span style=color:#57c7ff>push</span>(v);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 class=heading id=directed-cycle-detection>Directed cycle detection
<a href=#directed-cycle-detection>#</a></h4><p>To find out if a given digraph is a DAG, we can try to find a directec cycle in the digraph.
Use DFS and a stack to track the cycle.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#78787e>// TODO</span>
</span></span></code></pre></div><p>Some very typical applications of directed cycle detection and topological sort:
(A directed cycle means the problem is infeasible)</p><ul><li>job schedule</li><li>course scuedule</li><li>inheritance</li><li>spreadsheet<ul><li>vertex: cell</li><li>edge: formula</li></ul></li><li>symbolic links</li></ul><h3 class=heading id=strong-components>Strong components
<a href=#strong-components>#</a></h3><p>Vertices v and w are <strong>strongly connected</strong> if there is both a directed path from v to w and a directed path from w to v.
Strong connectivity is an equvicalence relation.</p><h4 class=heading id=kosaraju-sharir-algorithm>Kosaraju-Sharir Algorithm
<a href=#kosaraju-sharir-algorithm>#</a></h4><p>Kosaraju-Sharir is easy to implement but difficutl to understand. It runs DFS twice:</p><ul><li>Given a digraph G, run DFS to compute the topological order of its reverse $G^R$</li><li>Run DFS on G in the order given by first DFS</li></ul><p>TODO: ADD Proof</p><p><a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html</a></p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>KosarajuSharirSCC</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[]</span> marked;     <span style=color:#78787e>// marked[v] = has vertex v been visited?</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[]</span> id;             <span style=color:#78787e>// id[v] = id of strong component containing v</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>int</span> count;            <span style=color:#78787e>// number of strongly-connected components</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>/**
</span></span></span><span style=display:flex><span><span style=color:#78787e>     * Computes the strong components of the digraph {@code G}.
</span></span></span><span style=display:flex><span><span style=color:#78787e>     * @param G the digraph
</span></span></span><span style=display:flex><span><span style=color:#78787e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>KosarajuSharirSCC</span>(Digraph G) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// compute reverse postorder of reverse graph</span>
</span></span><span style=display:flex><span>        DepthFirstOrder dfs <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> DepthFirstOrder(G.<span style=color:#57c7ff>reverse</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// run DFS on G, using reverse postorder to guide calculation</span>
</span></span><span style=display:flex><span>        marked <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        id <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>int</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v : dfs.<span style=color:#57c7ff>reversePost</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span>) {
</span></span><span style=display:flex><span>                dfs(G, v);
</span></span><span style=display:flex><span>                count<span style=color:#ff6ac1>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// DFS on graph G</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>dfs</span>(Digraph G, <span style=color:#9aedfe>int</span> v) { 
</span></span><span style=display:flex><span>        marked<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>        id<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> count;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> w : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>marked<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>) dfs(G, w);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 class=heading id=minimum-spanning-trees>Minimum Spanning Trees
<a href=#minimum-spanning-trees>#</a></h2><p>An edge-weighted-graph is a graph where we associate weight or costs with each edge.
A spanning tree of an undirected edge-weighted graph G is a subgraph T that is both <strong>a tree (conneted and acyclic)</strong> and <strong>spanning (includes all of the vertices)</strong>.
Given an (connected) undirected edge-weighted graph G with V vertices and E edges, the MST of it must have <strong>V - 1</strong> edges.
If the graph is not connceted, we compute minimum spanning forest (MST of each component).</p><ul><li>A <em>cut</em> in a graph is a partition of its vertices into two (nonempty) sets</li><li>A <em>crossing edge</em> connects a vertex in one set with a vertex in the other.</li><li>Cut property: Given any cut, the crossing edge of min weight is in the MST.</li></ul><h3 class=heading id=edge-weight-graph-data-type>Edge-weight Graph Data Type
<a href=#edge-weight-graph-data-type>#</a></h3><p>Edge:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html</a></p><p>EdgeWeigthedGraph:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html</a></p><h3 class=heading id=greedy-mst-algorithm><strong>Greedy MST Algorithm:</strong>
<a href=#greedy-mst-algorithm>#</a></h3><ul><li>Start with all edges colored gray.</li><li>Find cut with no blacked crossing edges; color its min-weight edge black.</li><li>Repeat until V-1 edges are colored black.</li></ul><h3 class=heading id=implementations-1-kruskals-algorithm>Implementations 1: Kruskal&rsquo;s algorithm
<a href=#implementations-1-kruskals-algorithm>#</a></h3><p>For edges in ascending order of weight:</p><ul><li>Add next edge to Tree unless doing so would create a cycle.</li></ul><p>To efficiently solve this problem, use union-find :</p><ol><li>use a priority queue to maintain all the edges in V</li><li>union-find data structure:<ul><li>maintain a set for each connected component in T.</li><li>if v and w are in saome set, then adding v->w would create a cycle</li><li>to add v>w to T, merge sets containing v and w.</li></ul></li></ol><p>TODO: Add code</p><h3 class=heading id=implementations-2-prims-algorithm>Implementations 2: Prim&rsquo;s algorithm
<a href=#implementations-2-prims-algorithm>#</a></h3><ul><li>Start with vertex 0 and greedily grow tree T.</li><li>Add To T the min weight edge with exactly oue endpoint in T.</li><li>Reapeat unitl V - 1 edges.</li></ul><p>The key to solve this problem is how do we find the crossing edge of minimal weight efficiently.</p><p>A lazy solution (in time proportional to $ElogE$, fair enough):</p><ol><li>Maintain a PQ of edges with (at least) one endpoint in T<ul><li>Key = edge, priority = weight</li></ul></li><li>Delete-min to determine next edge e = v->w to add to T</li><li>Disregard if both endpoints v and w are marked (both in T)</li><li>Otherwise, let w be the unmarked vertex (not in T)<ul><li>add to PQ and edge incident to w (assuming other endpoint not in T)</li><li>add e to T and mark w</li></ul></li></ol><p>TODO: add code</p><p>A eager solution (in time proprotional to $ElogV$, better):</p><ol><li>Maintain a PQ of vertices connected by an edge to T, where priority of v = weight of shortedt edge connecting v to T</li><li>Delete min vertex v and add its associated edge e = v->w to T</li><li>Update PQ by considering all edges e = v->x incident to v<ul><li>ignore if x is already in T</li><li>add x to PQ if not alread on it</li><li>decrease priority of x if v->x becomes shortest edge connecting x to T</li></ul></li></ol><p>This solution uses an <a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html>indexed priority queue</a> data structure.</p><p>TODO: add code</p><h2 class=heading id=shortest-paths>Shortest Paths
<a href=#shortest-paths>#</a></h2><p><strong>Some variants:</strong></p><ul><li>Which vertices?<ul><li>Single source</li><li>Source-sink</li><li>All pairs</li></ul></li><li>Edge weights<ul><li>Nonegative weights</li><li>Euclidean weights</li><li>Arbitrary weights</li></ul></li><li>Cycles?<ul><li>No directed cycles</li><li>No negative cycles</li></ul></li></ul><h3 class=heading id=edge-weighted-digraph-data-strcuture>Edge-weighted digraph data strcuture
<a href=#edge-weighted-digraph-data-strcuture>#</a></h3><p>Weighted directed edge:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html</a></p><p>Edge-weighted digraph:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html</a></p><p>Use adjacency-lists implementation same as <a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html>EdgeWeightedGraph</a></p><h3 class=heading id=generic-single-source-shortest-paths>Generic Single-source Shortest paths
<a href=#generic-single-source-shortest-paths>#</a></h3><p>Our goal is to find the shortest path from s to every other vertex. As a result, what we find will be the <strong>shortest-paths tree (SPT)</strong> for source s.</p><h4 class=heading id=relax-edge-e--v-w>Relax edge e = v->w
<a href=#relax-edge-e--v-w>#</a></h4><ul><li>distTo[v] is length of shortest known path from s to v</li><li>distTo[w] is length of shortest known path from s to w</li><li>esgeTo[w] is last edge on shortest known pathh from s to w</li><li>if e = v->w gives shorter path to w through v, update both distTo[w] and edgeTo[w]</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>relax</span>(DirectedEdge e) {
</span></span><span style=display:flex><span>    <span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> e.<span style=color:#57c7ff>from</span>(), w <span style=color:#ff6ac1>=</span> e.<span style=color:#57c7ff>to</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>&gt;</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>()) {
</span></span><span style=display:flex><span>        distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>();
</span></span><span style=display:flex><span>        edgeTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> e;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 class=heading id=optimality-conditions>Optimality conditions
<a href=#optimality-conditions>#</a></h4><p>Given an edge-weighted digraph G, distTo[] are the shortest path distances from s <strong>iff</strong>:</p><ul><li>distTo[s] = 0</li><li>For each vertex v, distTo[v] is the length of some path from s to v.</li><li>For each edge e = v->w, distTo[w] &lt;= distTo[v] + e.weight()</li></ul><h4 class=heading id=generic-algorithm>Generic algorithm
<a href=#generic-algorithm>#</a></h4><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Generic algorithm (to compute SPT from s) {
</span></span><span style=display:flex><span>    Initialize distTo[s] = 0 and distTo[v] = $\infty$
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Repeat until optimality conditions are satisfied:
</span></span><span style=display:flex><span>        - Relax any edge
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Efficient implementations:</p><ul><li>Nonnegative weights: <a href=#implement-1-dijkstras-algorithm>Dijkstra&rsquo;s algorithm</a></li><li>No directed cycles (DAGs): <a href=#implement-2-topological-sort-algorithm>Topological sort algorithm</a></li><li>No negative cycles: <a href=#implement-3-bellman-ford-algorithm>Bellman-Ford</a></li></ul><h3 class=heading id=implement-1-dijkstras-algorithm>Implement 1: Dijkstra&rsquo;s algorithm
<a href=#implement-1-dijkstras-algorithm>#</a></h3><p>When there is no nonnegative weight exists, we can use Dijkstra&rsquo;s algorithm.</p><ul><li>Consider vertices in increasing order of distance from s (non-tree vertex with the lowest distTo[] value)</li><li>add vertex to tree and relax all edges pointing from that vertex</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#ff5c57>public</span> <span style=color:#ff5c57>class</span> <span style=color:#f3f99d>DijkstraSP</span>{
</span></span><span style=display:flex><span>        <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>DijkstraSP</span>(EdgeWeightedDigraph G, <span style=color:#9aedfe>int</span> s) {
</span></span><span style=display:flex><span>        edgeTo <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> DirectedEdge<span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        distTo <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>double</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        pq <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> IndexMinPQ<span style=color:#ff6ac1>&lt;</span>Double<span style=color:#ff6ac1>&gt;</span>(G.<span style=color:#57c7ff>V</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> 0; v <span style=color:#ff6ac1>&lt;</span> G.<span style=color:#57c7ff>V</span>(); v<span style=color:#ff6ac1>++</span>) {
</span></span><span style=display:flex><span>            distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> Double.<span style=color:#57c7ff>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        distTo<span style=color:#ff6ac1>[</span>s<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pq.<span style=color:#57c7ff>insert</span>(s, 0.<span style=color:#57c7ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>while</span>(<span style=color:#ff6ac1>!</span>pq.<span style=color:#57c7ff>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#9aedfe>int</span> v<span style=color:#ff6ac1>=</span> pq.<span style=color:#57c7ff>delMin</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>for</span> (DirectedEdge e : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>                relax(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>relax</span>(DirectedEdge e) {
</span></span><span style=display:flex><span>        <span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> e.<span style=color:#57c7ff>from</span>(), w <span style=color:#ff6ac1>=</span> e.<span style=color:#57c7ff>to</span>();
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>if</span> (distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>&gt;</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>()) {
</span></span><span style=display:flex><span>            distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>();
</span></span><span style=display:flex><span>            edgeTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (pq.<span style=color:#57c7ff>contains</span>(w)) pq.<span style=color:#57c7ff>decreaseKey</span>(w, distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>);
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>else</span> pq.<span style=color:#57c7ff>insert</span>(w, distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Compare to Prim&rsquo;s algorithm:</strong></p><ul><li>Both are computing a graph&rsquo;s spanning tree</li><li>Prim&rsquo;s algorithm choose closest vertex to tree as next vertex, while Dijkstra&rsquo;s algorithm choose closest vertex to the source</li></ul><h3 class=heading id=implement-2-topological-sort-algorithm>Implement 2: Topological sort algorithm
<a href=#implement-2-topological-sort-algorithm>#</a></h3><p>When the graph is a DAG, we can consider vertices in topological order and do relaxing.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>    <span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>    Topological topological <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> Topological(G);
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v : topological.<span style=color:#57c7ff>order</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (DirectedEdge e : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>            relax(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong><a href=https://en.wikipedia.org/wiki/Seam_carving>Seam carving</a></strong>: Resize an image without distortion.</p><p><strong>Longest paths</strong>:</p><ul><li>Formuate as a shortest paths problem in edge-weighted DAGs<ul><li>Negate all weights</li><li>Find shortest paths</li><li>Negate weights in result</li></ul></li><li>Allpication: Parallel job scheduling (<a href=https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%83%86%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%91%E3%82%B9%E6%B3%95>Critical path method, CPM</a>).</li></ul><h3 class=heading id=implement-3-bellman-ford-algorithm>Implement 3: Bellman-Ford algorithm
<a href=#implement-3-bellman-ford-algorithm>#</a></h3><blockquote><p>A SPT exists iff no negative cycles (a directed cycle whose sum of edge weights is negative).</p></blockquote><p>When we want to find shortest paths with nagative weights, Dijkstra&rsquo;s algorithms doesn&rsquo;t work.
We can use Bellman-Ford algorithm as long as there is no negative cycle in the graph.
(Bellman-Ford algorithm is a dynamic programming algorithm)</p><ul><li>Initialize distTo[s] = 0 and distTo[v] = $\infty$</li><li>Maintain a queue and repeat until the queue is empty or find a cycle:<ul><li>Pop vertex v from q</li><li>Relax each edge pointing from v to any vertex w:<ul><li>if distTo[w] can be de decreased, update distTo[w] and add w to the queue</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#78787e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>public</span> <span style=color:#57c7ff>BellmanFordSP</span>(EdgeWeightedDigraph G, <span style=color:#9aedfe>int</span> s) {
</span></span><span style=display:flex><span>        distTo  <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>double</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        edgeTo  <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> DirectedEdge<span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        onQueue <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> <span style=color:#9aedfe>boolean</span><span style=color:#ff6ac1>[</span>G.<span style=color:#57c7ff>V</span>()<span style=color:#ff6ac1>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (<span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> 0; v <span style=color:#ff6ac1>&lt;</span> G.<span style=color:#57c7ff>V</span>(); v<span style=color:#ff6ac1>++</span>)
</span></span><span style=display:flex><span>            distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> Double.<span style=color:#57c7ff>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        distTo<span style=color:#ff6ac1>[</span>s<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> 0.<span style=color:#57c7ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Bellman-Ford algorithm</span>
</span></span><span style=display:flex><span>        queue <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>new</span> Queue<span style=color:#ff6ac1>&lt;</span>Integer<span style=color:#ff6ac1>&gt;</span>();
</span></span><span style=display:flex><span>        queue.<span style=color:#57c7ff>enqueue</span>(s);
</span></span><span style=display:flex><span>        onQueue<span style=color:#ff6ac1>[</span>s<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>while</span> (<span style=color:#ff6ac1>!</span>queue.<span style=color:#57c7ff>isEmpty</span>() <span style=color:#ff6ac1>&amp;&amp;</span> <span style=color:#ff6ac1>!</span>hasNegativeCycle()) {
</span></span><span style=display:flex><span>            <span style=color:#9aedfe>int</span> v <span style=color:#ff6ac1>=</span> queue.<span style=color:#57c7ff>dequeue</span>();
</span></span><span style=display:flex><span>            onQueue<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>false</span>;
</span></span><span style=display:flex><span>            relax(G, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff5c57>private</span> <span style=color:#9aedfe>void</span> <span style=color:#57c7ff>relax</span>(EdgeWeightedDigraph G, <span style=color:#9aedfe>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>for</span> (DirectedEdge e : G.<span style=color:#57c7ff>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#9aedfe>int</span> w <span style=color:#ff6ac1>=</span> e.<span style=color:#57c7ff>to</span>();
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>&gt;</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>()) {
</span></span><span style=display:flex><span>                distTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> distTo<span style=color:#ff6ac1>[</span>v<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>+</span> e.<span style=color:#57c7ff>weight</span>();
</span></span><span style=display:flex><span>                edgeTo<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> e;
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span>onQueue<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span>) {
</span></span><span style=display:flex><span>                    queue.<span style=color:#57c7ff>enqueue</span>(w);
</span></span><span style=display:flex><span>                    onQueue<span style=color:#ff6ac1>[</span>w<span style=color:#ff6ac1>]</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>++</span>cost <span style=color:#ff6ac1>%</span> G.<span style=color:#57c7ff>V</span>() <span style=color:#ff6ac1>==</span> 0) {
</span></span><span style=display:flex><span>                findNegativeCycle();
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (hasNegativeCycle()) <span style=color:#ff6ac1>return</span>;  <span style=color:#78787e>// found a negative cycle</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Bellman-Ford algorithm can also be used for finding a negative cycle.</p><p>Negative cycle application: arbitrage detection.</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>â</div><div class=single-pagination-text><a href=/section2/2020-04-29-subtyping/>Programming Language - Subtyping</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/section2/2020-06-06-changes-in-java-string/>Changes to String in java (from 1.7.0_06)</a></div><div class=single-pagination-text>â</div></div></div></div><hr></div><div class=back-to-top><a href=#top>â Back to top</a></div></div></main></div><footer><div class=footer><p>Â© 2024 <a href=https://github.com/loyistro/Beige>loyistro/beige</a> theme</p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>