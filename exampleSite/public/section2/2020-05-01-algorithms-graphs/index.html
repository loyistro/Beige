<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=stylesheet href=/chroma/base16-snazzy.css><link rel=icon type=image/ico href=http://localhost:1313/favicon//favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=http://localhost:1313/favicon//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=http://localhost:1313/favicon//apple-touch-icon.png><meta name=description content><title>Algorithms - Graphs | My website
</title><link rel=canonical href=http://localhost:1313/section2/2020-05-01-algorithms-graphs/><meta property="og:url" content="http://localhost:1313/section2/2020-05-01-algorithms-graphs/"><meta property="og:site_name" content="My website"><meta property="og:title" content="Algorithms - Graphs"><meta property="og:description" content="Undirected Graphs # Some problems # Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once classical NP-complete problem. Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical? No one knows so far. A lonstanding open problem Representations # Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="section2"><meta property="article:published_time" content="2020-05-01T09:00:00+00:00"><meta property="article:modified_time" content="2020-05-01T09:00:00+00:00"><meta property="article:tag" content="Algorithms"><link rel=stylesheet href=/assets/combined.min.8beb6748a727b778e506884b5902e081ca4483fb407b1d82de6f4366f2156c9b.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=http://localhost:1313/ style=display:flex;align-items:center><span>Gofun Theme</span></a></h1><div class="menu flex"><p class=menu-item><a href=http://localhost:1313/>/home</a></p><p class=menu-item><a href=http://localhost:1313/section1/>/Section1</a></p><p class=menu-item><a href=http://localhost:1313/section2/>/Section2</a></p></div><hr></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>/ </span><a href=/section2/>Section 2</a>
<span class=breadcrumbs-separator>/ </span><a class=breadcrumbs-current href=/section2/2020-05-01-algorithms-graphs/>Algorithms - Graphs</a></div><div class=autonumber><div class=single-intro-container><h1 class=single-title>Algorithms - Graphs</h1><p class=single-readtime><time datetime=2020-05-01T09:00:00+00:00>May 1, 2020</time>
&nbsp; · &nbsp;
12 min read
&nbsp; · &nbsp;
<span class=single-tags><a href=/tags/algorithms/>#Algorithms
</a><a href=/tags/>#Tags</a></span></p></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#undirected-graphs>Undirected Graphs</a><ul><li><a href=#some-problems>Some problems</a></li><li><a href=#representations>Representations</a></li><li><a href=#adjacency-list-data-structure>Adjacency-list Data structure</a></li><li><a href=#depth-first-search-dfs>Depth-first Search (DFS)</a></li><li><a href=#breadth-first-search-bfs>Breadth-first Search (BFS)</a></li><li><a href=#applications-of-dfs>Applications of DFS</a></li></ul></li><li><a href=#directed-graphs>Directed Graphs</a><ul><li><a href=#representations-1>Representations</a></li><li><a href=#digraph-search>Digraph search</a></li><li><a href=#topological-sort>Topological Sort</a></li><li><a href=#strong-components>Strong components</a></li></ul></li><li><a href=#minimum-spanning-trees>Minimum Spanning Trees</a><ul><li><a href=#edge-weight-graph-data-type>Edge-weight Graph Data Type</a></li><li><a href=#greedy-mst-algorithm><strong>Greedy MST Algorithm:</strong></a></li><li><a href=#implementations-1-kruskals-algorithm>Implementations 1: Kruskal&rsquo;s algorithm</a></li><li><a href=#implementations-2-prims-algorithm>Implementations 2: Prim&rsquo;s algorithm</a></li></ul></li><li><a href=#shortest-paths>Shortest Paths</a><ul><li><a href=#edge-weighted-digraph-data-strcuture>Edge-weighted digraph data strcuture</a></li><li><a href=#generic-single-source-shortest-paths>Generic Single-source Shortest paths</a></li><li><a href=#implement-1-dijkstras-algorithm>Implement 1: Dijkstra&rsquo;s algorithm</a></li><li><a href=#implement-2-topological-sort-algorithm>Implement 2: Topological sort algorithm</a></li><li><a href=#implement-3-bellman-ford-algorithm>Implement 3: Bellman-Ford algorithm</a></li></ul></li></ul></nav></aside><div class=single-content><h2 class=heading id=undirected-graphs>Undirected Graphs
<a href=#undirected-graphs>#</a></h2><h3 class=heading id=some-problems>Some problems
<a href=#some-problems>#</a></h3><ul><li>Path</li><li>Shortest path</li><li>Cycle</li><li>Ehler tour: A cycle that uses each edge excatly once.</li><li>Hamilton tour: A cycle that uses each vertex exactly once<ul><li>classical NP-complete problem.</li></ul></li><li>Connectivity</li><li>MST:</li><li>Biconnectivity: A vertex whose removal disconnects the graph</li><li>Planarity</li><li>Graph isomorphism: Are two graphs identical?<ul><li>No one knows so far. A lonstanding open problem</li></ul></li></ul><h3 class=heading id=representations>Representations
<a href=#representations>#</a></h3><p>Real-world graphs tend to be <strong>sparse</strong> (huge number of vertices, small average vertex degree).</p><ul><li>Set-of-edges representation<ul><li>unefficient</li></ul></li><li>Adjacency-matrix representation<ul><li>space cost is prohibitive</li></ul></li><li>Adjacency-list array representation<ul><li>GOOD</li></ul></li></ul><h3 class=heading id=adjacency-list-data-structure>Adjacency-list Data structure
<a href=#adjacency-list-data-structure>#</a></h3><ul><li>Space usage proportional to V + E</li><li>Constant time to add an edge</li><li>Time proportional to the degree of v to iterate through vertices adjacent to v</li></ul><h3 class=heading id=depth-first-search-dfs>Depth-first Search (DFS)
<a href=#depth-first-search-dfs>#</a></h3><p>Typical applications:</p><ul><li>Find all vertices connected to a given source vertex</li><li>Find a path between two vertices</li></ul><p>Algorithm:</p><ul><li>Use recursion (a function-call stack) or an explicit stack.</li><li>Mark each visited vertex (and keep track of edge taken to visit it)</li><li>Return (retrace steps) when no unvisited options</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DepthFirstPaths</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>blloean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTO</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DepthFirstPaths</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>Gm</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Propositions:</p><ol><li>DFS marks all vertices connected to s in time proportional to the sum of their degrees.</li><li>After DFS, can find vertices connected to s in constant time and can find a path to s in time proportional to its length.</li></ol><h3 class=heading id=breadth-first-search-bfs>Breadth-first Search (BFS)
<a href=#breadth-first-search-bfs>#</a></h3><p>Typical applications:</p><ul><li>shortest path</li></ul><p>Algorithm:</p><ul><li>Put s onto a queue, and mark s as visited</li><li>Take the next vertex v from the queue and mark it</li><li>Put onto the queue all unmarked vertices that are adjacent to v</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>BreadthFirstPaths</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>edgeTo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>bfs</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>q</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ture</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=na>dequeue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>q</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Proposition:</p><ol><li>BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V</li></ol><h3 class=heading id=applications-of-dfs>Applications of DFS
<a href=#applications-of-dfs>#</a></h3><h4 class=heading id=connected-components>Connected components
<a href=#connected-components>#</a></h4><p>The goal is to preprocess graph to answer queries of the form <em>is v connected to w?</em> in constant time.</p><p>The relation <em>is connected to</em> is an equivalence relation:</p><ul><li>Reflexive: v is connected to v</li><li>Symmetric: if v is connected to w, then w is connected to v</li><li>Transitive: if v connected to w and w connected to x, then v connected to x</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CC</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>CC</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Graph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>id</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 class=heading id=cycle-detection>Cycle detection
<a href=#cycle-detection>#</a></h4><p>Problem: Is a given graph acylic?</p><p><strong>TODO</strong></p><h4 class=heading id=two-colorability>Two-colorability
<a href=#two-colorability>#</a></h4><p>Problem: Is the graph bipartite?</p><p><strong>TODO</strong></p><h4 class=heading id=symbol-graphs>Symbol graphs
<a href=#symbol-graphs>#</a></h4><p><strong>TODO</strong></p><h4 class=heading id=degrees-of-separation>Degrees of separation
<a href=#degrees-of-separation>#</a></h4><p><strong>TODO</strong></p><h2 class=heading id=directed-graphs>Directed Graphs
<a href=#directed-graphs>#</a></h2><blockquote><p>A directed graph (or digraph) is a set of vertices and a collection of directed edges. Each directed edge connects an ordered pair of vertices.</p></blockquote><ul><li><em>outdegree</em>: the number of edges going <strong>from</strong> it</li><li><em>indegree</em>: the number fo edges going <strong>into</strong> it</li><li><em>directed path</em>: a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence</li><li><em>directed cycle</em></li><li><em>simple cycle</em>: a cycle with no repeated edges or vertices</li></ul><h3 class=heading id=representations-1>Representations
<a href=#representations-1>#</a></h3><p>Again, use <a href=#Adjacency-list-Data-structure>adjacency-lists representation</a></p><ul><li>Based on iterating over vertices pointing from v</li><li>Real-world digraphs tend to be sparse</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Digraph</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>V</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Bag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>adj</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Digraph</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>V</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>V</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>V</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>adj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Bag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span><span class=p>)</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Bag</span><span class=o>[</span><span class=n>V</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>V</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Bag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addEdge</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>adj</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 class=heading id=digraph-search>Digraph search
<a href=#digraph-search>#</a></h3><p>Reachabiliity problem: Find all vertices reachable from s along a directed path.</p><p>We can use <a href=#Depth-first-Search-(DFS)>the same dfs method as for undirected graphs</a>.</p><ul><li>Every undirected graph is a digraph with edges in both directions.</li><li>DFS is a digraph algorithm,</li></ul><p>Reachability applications:</p><ul><li>program control-flow analysis<ul><li>Dead-code elimination</li><li>infinite-loop detection</li></ul></li><li>mark-sweep garbage collector</li></ul><p>Other DFS problems:</p><ul><li>Path findind</li><li>Topological sort</li><li>Directed cycle detection</li><li>&mldr;</li></ul><p>BFS problems:</p><ul><li>shortest path</li><li>multiple-source shortest paths</li><li>web crawler application</li></ul><h3 class=heading id=topological-sort>Topological Sort
<a href=#topological-sort>#</a></h3><blockquote><p>Topological sort: Given a digraph, put the vertices in order such that all its directed edges point from a vertix earlier in the order to a vertex later in the order (or report impossible).</p></blockquote><p>A digraph has a topological order <strong>if and only if</strong> it is a <em>directed acyclic graph</em> (DAG).
Topological sort redraws DAG so all edges poitn upwards.</p><p>use <strong>DFS</strong> again. It can be proved that reverse postorder of a DAG is a topological order.
(check P578 for the definition of Preorder/Postorder)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DepthFirstOrder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>reversePost</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>publiv</span><span class=w> </span><span class=nf>DepthFirstOrder</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>reversePost</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Digrapg</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>reversePost</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 class=heading id=directed-cycle-detection>Directed cycle detection
<a href=#directed-cycle-detection>#</a></h4><p>To find out if a given digraph is a DAG, we can try to find a directec cycle in the digraph.
Use DFS and a stack to track the cycle.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// TODO</span><span class=w>
</span></span></span></code></pre></div><p>Some very typical applications of directed cycle detection and topological sort:
(A directed cycle means the problem is infeasible)</p><ul><li>job schedule</li><li>course scuedule</li><li>inheritance</li><li>spreadsheet<ul><li>vertex: cell</li><li>edge: formula</li></ul></li><li>symbolic links</li></ul><h3 class=heading id=strong-components>Strong components
<a href=#strong-components>#</a></h3><p>Vertices v and w are <strong>strongly connected</strong> if there is both a directed path from v to w and a directed path from w to v.
Strong connectivity is an equvicalence relation.</p><h4 class=heading id=kosaraju-sharir-algorithm>Kosaraju-Sharir Algorithm
<a href=#kosaraju-sharir-algorithm>#</a></h4><p>Kosaraju-Sharir is easy to implement but difficutl to understand. It runs DFS twice:</p><ul><li>Given a digraph G, run DFS to compute the topological order of its reverse $G^R$</li><li>Run DFS on G in the order given by first DFS</li></ul><p>TODO: ADD Proof</p><p><a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>KosarajuSharirSCC</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>marked</span><span class=p>;</span><span class=w>     </span><span class=c1>// marked[v] = has vertex v been visited?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>             </span><span class=c1>// id[v] = id of strong component containing v</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>            </span><span class=c1>// number of strongly-connected components</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Computes the strong components of the digraph {@code G}.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param G the digraph
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>KosarajuSharirSCC</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// compute reverse postorder of reverse graph</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>DepthFirstOrder</span><span class=w> </span><span class=n>dfs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DepthFirstOrder</span><span class=p>(</span><span class=n>G</span><span class=p>.</span><span class=na>reverse</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// run DFS on G, using reverse postorder to guide calculation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>dfs</span><span class=p>.</span><span class=na>reversePost</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// DFS on graph G</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Digraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>id</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>count</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=n>dfs</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 class=heading id=minimum-spanning-trees>Minimum Spanning Trees
<a href=#minimum-spanning-trees>#</a></h2><p>An edge-weighted-graph is a graph where we associate weight or costs with each edge.
A spanning tree of an undirected edge-weighted graph G is a subgraph T that is both <strong>a tree (conneted and acyclic)</strong> and <strong>spanning (includes all of the vertices)</strong>.
Given an (connected) undirected edge-weighted graph G with V vertices and E edges, the MST of it must have <strong>V - 1</strong> edges.
If the graph is not connceted, we compute minimum spanning forest (MST of each component).</p><ul><li>A <em>cut</em> in a graph is a partition of its vertices into two (nonempty) sets</li><li>A <em>crossing edge</em> connects a vertex in one set with a vertex in the other.</li><li>Cut property: Given any cut, the crossing edge of min weight is in the MST.</li></ul><h3 class=heading id=edge-weight-graph-data-type>Edge-weight Graph Data Type
<a href=#edge-weight-graph-data-type>#</a></h3><p>Edge:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html</a></p><p>EdgeWeigthedGraph:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html</a></p><h3 class=heading id=greedy-mst-algorithm><strong>Greedy MST Algorithm:</strong>
<a href=#greedy-mst-algorithm>#</a></h3><ul><li>Start with all edges colored gray.</li><li>Find cut with no blacked crossing edges; color its min-weight edge black.</li><li>Repeat until V-1 edges are colored black.</li></ul><h3 class=heading id=implementations-1-kruskals-algorithm>Implementations 1: Kruskal&rsquo;s algorithm
<a href=#implementations-1-kruskals-algorithm>#</a></h3><p>For edges in ascending order of weight:</p><ul><li>Add next edge to Tree unless doing so would create a cycle.</li></ul><p>To efficiently solve this problem, use union-find :</p><ol><li>use a priority queue to maintain all the edges in V</li><li>union-find data structure:<ul><li>maintain a set for each connected component in T.</li><li>if v and w are in saome set, then adding v->w would create a cycle</li><li>to add v>w to T, merge sets containing v and w.</li></ul></li></ol><p>TODO: Add code</p><h3 class=heading id=implementations-2-prims-algorithm>Implementations 2: Prim&rsquo;s algorithm
<a href=#implementations-2-prims-algorithm>#</a></h3><ul><li>Start with vertex 0 and greedily grow tree T.</li><li>Add To T the min weight edge with exactly oue endpoint in T.</li><li>Reapeat unitl V - 1 edges.</li></ul><p>The key to solve this problem is how do we find the crossing edge of minimal weight efficiently.</p><p>A lazy solution (in time proportional to $ElogE$, fair enough):</p><ol><li>Maintain a PQ of edges with (at least) one endpoint in T<ul><li>Key = edge, priority = weight</li></ul></li><li>Delete-min to determine next edge e = v->w to add to T</li><li>Disregard if both endpoints v and w are marked (both in T)</li><li>Otherwise, let w be the unmarked vertex (not in T)<ul><li>add to PQ and edge incident to w (assuming other endpoint not in T)</li><li>add e to T and mark w</li></ul></li></ol><p>TODO: add code</p><p>A eager solution (in time proprotional to $ElogV$, better):</p><ol><li>Maintain a PQ of vertices connected by an edge to T, where priority of v = weight of shortedt edge connecting v to T</li><li>Delete min vertex v and add its associated edge e = v->w to T</li><li>Update PQ by considering all edges e = v->x incident to v<ul><li>ignore if x is already in T</li><li>add x to PQ if not alread on it</li><li>decrease priority of x if v->x becomes shortest edge connecting x to T</li></ul></li></ol><p>This solution uses an <a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html>indexed priority queue</a> data structure.</p><p>TODO: add code</p><h2 class=heading id=shortest-paths>Shortest Paths
<a href=#shortest-paths>#</a></h2><p><strong>Some variants:</strong></p><ul><li>Which vertices?<ul><li>Single source</li><li>Source-sink</li><li>All pairs</li></ul></li><li>Edge weights<ul><li>Nonegative weights</li><li>Euclidean weights</li><li>Arbitrary weights</li></ul></li><li>Cycles?<ul><li>No directed cycles</li><li>No negative cycles</li></ul></li></ul><h3 class=heading id=edge-weighted-digraph-data-strcuture>Edge-weighted digraph data strcuture
<a href=#edge-weighted-digraph-data-strcuture>#</a></h3><p>Weighted directed edge:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html</a></p><p>Edge-weighted digraph:
<a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html>https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html</a></p><p>Use adjacency-lists implementation same as <a href=https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html>EdgeWeightedGraph</a></p><h3 class=heading id=generic-single-source-shortest-paths>Generic Single-source Shortest paths
<a href=#generic-single-source-shortest-paths>#</a></h3><p>Our goal is to find the shortest path from s to every other vertex. As a result, what we find will be the <strong>shortest-paths tree (SPT)</strong> for source s.</p><h4 class=heading id=relax-edge-e--v-w>Relax edge e = v->w
<a href=#relax-edge-e--v-w>#</a></h4><ul><li>distTo[v] is length of shortest known path from s to v</li><li>distTo[w] is length of shortest known path from s to w</li><li>esgeTo[w] is last edge on shortest known pathh from s to w</li><li>if e = v->w gives shorter path to w through v, update both distTo[w] and edgeTo[w]</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>relax</span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>from</span><span class=p>(),</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>to</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 class=heading id=optimality-conditions>Optimality conditions
<a href=#optimality-conditions>#</a></h4><p>Given an edge-weighted digraph G, distTo[] are the shortest path distances from s <strong>iff</strong>:</p><ul><li>distTo[s] = 0</li><li>For each vertex v, distTo[v] is the length of some path from s to v.</li><li>For each edge e = v->w, distTo[w] &lt;= distTo[v] + e.weight()</li></ul><h4 class=heading id=generic-algorithm>Generic algorithm
<a href=#generic-algorithm>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Generic algorithm (to compute SPT from s) {
</span></span><span class=line><span class=cl>    Initialize distTo[s] = 0 and distTo[v] = $\infty$
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Repeat until optimality conditions are satisfied:
</span></span><span class=line><span class=cl>        - Relax any edge
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>Efficient implementations:</p><ul><li>Nonnegative weights: <a href=#implement-1-dijkstras-algorithm>Dijkstra&rsquo;s algorithm</a></li><li>No directed cycles (DAGs): <a href=#implement-2-topological-sort-algorithm>Topological sort algorithm</a></li><li>No negative cycles: <a href=#implement-3-bellman-ford-algorithm>Bellman-Ford</a></li></ul><h3 class=heading id=implement-1-dijkstras-algorithm>Implement 1: Dijkstra&rsquo;s algorithm
<a href=#implement-1-dijkstras-algorithm>#</a></h3><p>When there is no nonnegative weight exists, we can use Dijkstra&rsquo;s algorithm.</p><ul><li>Consider vertices in increasing order of distance from s (non-tree vertex with the lowest distTo[] value)</li><li>add vertex to tree and relax all edges pointing from that vertex</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DijkstraSP</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>DijkstraSP</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>double</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IndexMinPQ</span><span class=o>&lt;</span><span class=n>Double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=o>=</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>delMin</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>relax</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>relax</span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>from</span><span class=p>(),</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>to</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>pq</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>w</span><span class=p>))</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>decreaseKey</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>else</span><span class=w> </span><span class=n>pq</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>Compare to Prim&rsquo;s algorithm:</strong></p><ul><li>Both are computing a graph&rsquo;s spanning tree</li><li>Prim&rsquo;s algorithm choose closest vertex to tree as next vertex, while Dijkstra&rsquo;s algorithm choose closest vertex to the source</li></ul><h3 class=heading id=implement-2-topological-sort-algorithm>Implement 2: Topological sort algorithm
<a href=#implement-2-topological-sort-algorithm>#</a></h3><p>When the graph is a DAG, we can consider vertices in topological order and do relaxing.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Topological</span><span class=w> </span><span class=n>topological</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Topological</span><span class=p>(</span><span class=n>G</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>topological</span><span class=p>.</span><span class=na>order</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>relax</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong><a href=https://en.wikipedia.org/wiki/Seam_carving>Seam carving</a></strong>: Resize an image without distortion.</p><p><strong>Longest paths</strong>:</p><ul><li>Formuate as a shortest paths problem in edge-weighted DAGs<ul><li>Negate all weights</li><li>Find shortest paths</li><li>Negate weights in result</li></ul></li><li>Allpication: Parallel job scheduling (<a href=https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%83%86%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%91%E3%82%B9%E6%B3%95>Critical path method, CPM</a>).</li></ul><h3 class=heading id=implement-3-bellman-ford-algorithm>Implement 3: Bellman-Ford algorithm
<a href=#implement-3-bellman-ford-algorithm>#</a></h3><blockquote><p>A SPT exists iff no negative cycles (a directed cycle whose sum of edge weights is negative).</p></blockquote><p>When we want to find shortest paths with nagative weights, Dijkstra&rsquo;s algorithms doesn&rsquo;t work.
We can use Bellman-Ford algorithm as long as there is no negative cycle in the graph.
(Bellman-Ford algorithm is a dynamic programming algorithm)</p><ul><li>Initialize distTo[s] = 0 and distTo[v] = $\infty$</li><li>Maintain a queue and repeat until the queue is empty or find a cycle:<ul><li>Pop vertex v from q</li><li>Relax each edge pointing from v to any vertex w:<ul><li>if distTo[w] can be de decreased, update distTo[w] and add w to the queue</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>BellmanFordSP</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>double</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>edgeTo</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>DirectedEdge</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onQueue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>();</span><span class=w> </span><span class=n>v</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Double</span><span class=p>.</span><span class=na>POSITIVE_INFINITY</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>distTo</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Bellman-Ford algorithm</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>onQueue</span><span class=o>[</span><span class=n>s</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>hasNegativeCycle</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>dequeue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>onQueue</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>relax</span><span class=p>(</span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>relax</span><span class=p>(</span><span class=n>EdgeWeightedDigraph</span><span class=w> </span><span class=n>G</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>DirectedEdge</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>adj</span><span class=p>(</span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>to</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>weight</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>onQueue</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueue</span><span class=p>(</span><span class=n>w</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>onQueue</span><span class=o>[</span><span class=n>w</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>++</span><span class=n>cost</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>G</span><span class=p>.</span><span class=na>V</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>findNegativeCycle</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hasNegativeCycle</span><span class=p>())</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>  </span><span class=c1>// found a negative cycle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Bellman-Ford algorithm can also be used for finding a negative cycle.</p><p>Negative cycle application: arbitrage detection.</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>&lt;</div><div class=single-pagination-text><a href=/section2/2020-04-29-subtyping/>Programming Language - Subtyping</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/section2/2020-06-06-changes-in-java-string/>Changes to String in java (from 1.7.0_06)</a></div><div class=single-pagination-text>></div></div></div></div><hr></div><div class=back-to-top><a href=#top>↑ Back to top</a></div></div></main></div><footer><div class=footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/loyistro/Gofun>loyistro/gofun</a></p></div></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>